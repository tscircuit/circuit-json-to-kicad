import type { CircuitJson, SchematicPort } from "circuit-json"

export function buildSymbolDataFromSchematicPrimitives(
  circuitJson: CircuitJson,
  schematicSymbolId: string,
  schematicSymbol: any,
  schematicComponentId?: string,
): any {
  // Collect all primitives linked to this schematic_symbol
  const circles: any[] = circuitJson.filter(
    (el: any) =>
      el.type === "schematic_circle" &&
      el.schematic_symbol_id === schematicSymbolId,
  )
  // Collect lines with schematic_symbol_id (symbol body lines)
  const symbolLines: any[] = circuitJson.filter(
    (el: any) =>
      el.type === "schematic_line" &&
      el.schematic_symbol_id === schematicSymbolId,
  )
  // Also collect stem lines: lines with schematic_component_id but NO schematic_symbol_id
  // These are generated by schStemLength on ports
  const schLines: any[] = schematicComponentId
    ? circuitJson.filter(
        (el: any) =>
          el.type === "schematic_line" &&
          el.schematic_component_id === schematicComponentId &&
          !el.schematic_symbol_id,
      )
    : []
  const lines: any[] = [...symbolLines, ...schLines]
  const paths: any[] = circuitJson.filter(
    (el: any) =>
      el.type === "schematic_path" &&
      el.schematic_symbol_id === schematicSymbolId,
  )
  // Collect schematic_text elements for custom symbol text (e.g., +/- labels)
  const texts: any[] = circuitJson.filter(
    (el: any) =>
      el.type === "schematic_text" &&
      el.schematic_symbol_id === schematicSymbolId,
  )

  // Find ports - first try by schematic_symbol_id, then fall back to schematic_component_id
  let ports = circuitJson.filter(
    (el): el is SchematicPort =>
      el.type === "schematic_port" &&
      "schematic_symbol_id" in el &&
      el.schematic_symbol_id === schematicSymbolId,
  )

  // If no ports found by symbol id, try to find by component id
  if (ports.length === 0 && schematicComponentId) {
    // First try: only include ports with display_pin_label (custom symbol ports)
    ports = circuitJson.filter(
      (el): el is SchematicPort =>
        el.type === "schematic_port" &&
        el.schematic_component_id === schematicComponentId &&
        el.display_pin_label !== undefined,
    )

    // Second try: if no ports with display_pin_label, get all ports and deduplicate by pin_number
    if (ports.length === 0) {
      const allPorts = circuitJson.filter(
        (el): el is SchematicPort =>
          el.type === "schematic_port" &&
          el.schematic_component_id === schematicComponentId,
      )

      const seenPinNumbers = new Set<number>()
      ports = allPorts.filter((port) => {
        const pinNum = port.pin_number
        if (pinNum !== undefined) {
          if (seenPinNumbers.has(pinNum)) {
            return false // Skip duplicate
          }
          seenPinNumbers.add(pinNum)
        }
        return true
      })
    }
  }

  // Convert to internal primitive format
  const primitives: any[] = []

  // Convert schematic_circle to circle primitives
  for (const circle of circles) {
    primitives.push({
      type: "circle",
      x: circle.center?.x ?? 0,
      y: circle.center?.y ?? 0,
      radius: circle.radius ?? 0.5,
      fill: circle.is_filled ?? false,
      fillColor: circle.fill_color,
    })
  }

  // Convert schematic_line to path primitives (2-point paths)
  for (const line of lines) {
    primitives.push({
      type: "path",
      points: [
        { x: line.x1 ?? 0, y: line.y1 ?? 0 },
        { x: line.x2 ?? 0, y: line.y2 ?? 0 },
      ],
    })
  }

  // Convert schematic_path to path primitives
  for (const path of paths) {
    if (path.points && path.points.length > 0) {
      primitives.push({
        type: "path",
        points: path.points,
        fill: path.is_filled ?? false,
        fillColor: path.fill_color,
      })
    }
  }

  // Convert schematic_text to text primitives
  const symbolTexts = texts.map((text: any) => ({
    text: text.text ?? "",
    x: text.position?.x ?? 0,
    y: text.position?.y ?? 0,
    fontSize: text.font_size ?? 0.2,
    anchor: text.anchor ?? "center",
  }))

  // Convert schematic_port to ports
  const symbolPorts = ports.map((port, index) => ({
    x: port.center?.x ?? 0,
    y: port.center?.y ?? 0,
    labels: [port.display_pin_label || `${port.pin_number || index + 1}`],
    pinNumber: port.pin_number || index + 1,
    facingDirection: port.facing_direction,
  }))

  // Sort ports by pin_number
  symbolPorts.sort((a, b) => a.pinNumber - b.pinNumber)

  return {
    center: schematicSymbol.center || { x: 0, y: 0 },
    size: schematicSymbol.size || { width: 1, height: 1 },
    primitives,
    texts: symbolTexts,
    ports: symbolPorts,
  }
}
